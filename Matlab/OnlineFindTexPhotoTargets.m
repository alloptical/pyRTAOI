%% Determine photostimulation groups 
% generate files for photostim experiments
% using result files generated by OnlineProcTexture.m and OnlinePhotoexcitability.m
% ZZ 2019
clear all
%% setup bruker1 dropbox path (only necassary if not using pyRTAOI to control photostim)
BrukerDropboxPath = 'C:\Users\Zihui\Dropbox\Bruker1';
addpath(genpath([BrukerDropboxPath '\SLM\']));
addpath(BrukerDropboxPath)

%% load proc file
try
    [tex_file,tex_path] = uigetfile('*.mat','Select ProcTex data');
    disp(['Loaded ProcTex file :',fullfile(tex_path,tex_file)])
    load(fullfile(tex_path,tex_file));
catch
    warning('tex file not loaded')
end

try
    [photo_file,photo_path] = uigetfile('*.mat','Select ProcPhotoExci data',tex_path);
    disp(['Loaded file :',fullfile(photo_path,photo_file)])
    load(fullfile(photo_path,photo_file));
catch
    warning('photo file not loaded')
end


% check if animal and date matches
[tex_file_name] = parse_rtaoi_result_name(tex_file);
[photo_file_name] = parse_rtaoi_result_name(photo_file);
if strcmp(tex_file_name.animal, photo_file_name.animal)==0 || strcmp(tex_file_name.date, photo_file_name.date)==0
    warning('ANIMAL OR DATE MISMATCH! ')
else
    animal_name = tex_file_name.animal;
    exp_date = tex_file_name.date;
end

% check if cnm indices match
tex_cnm_idx = extractfield(tex_output_struct.cell_struct,'cnm_idx');
photo_cnm_idx = extractfield(photo_output_struct.cell_struct,'cnm_idx');

if isequal(tex_cnm_idx, photo_cnm_idx)
    disp('Component idx matched')
    cnm_idx = tex_cnm_idx;
    num_cells = length(cnm_idx);
else
    warning('Component idx mismatch! - check loaded files')
end

%% set params - CHANGE THIS
% keep using loaded params 
opt = tex_output_struct.opt;
opt.opt_photo = photo_output_struct.opt;

% keep notes of loaded file paths
opt.tex_file_name = tex_file;
opt.photo_file_name = photo_file;

% config experiment
opt.exp_num_targets  = 5;    % expected number of targets per photostim group 
opt.tot_num_trials   = 180;  % total number of trials (should be same as pybehav trialOrder)
opt.max_num_consecutive = 3; % max number of consecutive trials with same type of sensory stimuli 

% trigger generator inputs
opt.trial_interval   = 10;   % interval between trialon triggers, i.e., trial length (sec)
opt.stim_start_time  = 3;    % time delay between trialon trigger and photostim trigger (sec)
opt.sample_rate_hz   = 1000; % packio output sample rate  
opt.trig_dur_msecs   = 5;         %impulse duration in milliseconds

% config trial types
trial_type_tex           = [1 1 1 2 2 2 0 0 0];
trial_type_photo         = [1,2,0,1,2,0,1,2,0];
relative_type_fraction   = [1 1 1 1 1 1 1 1 1]; % change this 
opt.trial_type_fraction = relative_type_fraction./sum(relative_type_fraction);

 
num_trial_types = 9;
trial_type_names = cell(1,num_trial_types);
for i = 1:num_trial_types
    trial_type_names{i} = ['tex' num2str(trial_type_tex(i)) '_photo' num2str(trial_type_photo(i))];
end
num_trials_per_type = round(opt.tot_num_trials.*opt.trial_type_fraction);

% config plot color
[plot_color] = online_tex_init_color();

%% config save path
opt.save_name_ext = datestr(now,'HHMMSS');
exp_folder_name = ['TexPhotoConfig_' exp_date '_' animal_name ...
    '_Tt_' tex_file_name.tseries ...
    '_Pt_' photo_file_name.tseries ...
    '_' opt.save_name_ext];

save_path = [tex_path filesep exp_folder_name];
if ~exist(save_path, 'dir')
mkdir(save_path)
end


target_tiff_save_path = [save_path filesep 'targets'];
if ~exist(target_tiff_save_path, 'dir')
    mkdir(target_tiff_save_path)
end

pack_trigger_save_path = [save_path filesep 'packIO_triggers'];
if ~exist(pack_trigger_save_path, 'dir')
    mkdir(pack_trigger_save_path)
end
%% config trial order
trial_type_idx = 1:num_trial_types;
all_trial_types_idx = cell2mat(arrayfun(@(x)ones(1,num_trials_per_type(x)).*x,trial_type_idx,'UniformOutput',false));
photo_trial_types_idx = cell2mat(arrayfun(@(x)ones(1,num_trials_per_type(x)).*trial_type_photo(x),trial_type_idx,'UniformOutput',false));
tex_trial_types_idx = cell2mat(arrayfun(@(x)ones(1,num_trials_per_type(x)).*trial_type_tex(x),trial_type_idx,'UniformOutput',false));

% shuffle
shuff_trial_order =  get_shuff_trial_idx(tex_trial_types_idx,opt.max_num_consecutive);
shuff_all_trial_types_idx = all_trial_types_idx(shuff_trial_order);
shuff_photo_trial_types_idx = photo_trial_types_idx(shuff_trial_order);
shuff_tex_trial_types_idx = tex_trial_types_idx(shuff_trial_order);

%% merge cell struct into one
cell_struct = struct();
photo_fds = fields(photo_output_struct.cell_struct);
tex_fds = fields(tex_output_struct.cell_struct);

for c = 1:num_cells
    for f = 1:numel(photo_fds)
        cell_struct(c).(photo_fds{f}) = photo_output_struct.cell_struct(c).(photo_fds{f});
    end
    for f = 1:numel(tex_fds)
        cell_struct(c).(tex_fds{f}) = tex_output_struct.cell_struct(c).(tex_fds{f});
    end
    
    cell_struct(c).centroid = cell_struct(c).jsf.centroid;
    cell_struct(c).coordinates = cell_struct(c).jsf.coordinates;
end

%% plot photo and texture auc
figure('name','auc plots','position',[100 100 800 400])
subplot(1,2,1)
hold on
histogram(extractfield(cell_struct,'photo_auc_zscore'),'facecolor',[.7 .7 .7],'edgecolor','none','BinWidth',.5)
histogram(extractfield(cell_struct(extractfield(cell_struct,'is_photo')==1),'photo_auc_zscore'),'facecolor','none','edgecolor',[1,0,0],'BinWidth',.5)

axis square
xlabel('Photo response auc (zscore)')

subplot(1,2,2)
hold on
histogram(extractfield(cell_struct,'tex_auc_zscore'),'facecolor',[.7 .7 .7],'edgecolor','none','BinWidth',.5)
histogram(extractfield(cell_struct(extractfield(cell_struct,'is_tuned')==1),'tex_auc_zscore'),'facecolor','none','edgecolor',[0,0,1],'BinWidth',.5)
xlabel('Tex response auc (zscore)')
axis square

%% show photostim response and texture response on FOV
figure('name','response amp fov','position',[100 100 1200 800])

ax2 = subplot(1,3,1);
plot_value_in_rois( cell_struct, 'sta_amp_correct_stim_1',[256 256],ax2,'IF_NORM_PIX',0,'IF_CONTOUR',0);
set(gca,'Ydir','reverse')
title('Tex1 response (correct trials)')

ax2 = subplot(1,3,2);
plot_value_in_rois( cell_struct, 'sta_amp_correct_stim_2',[256 256],ax2,'IF_NORM_PIX',0,'IF_CONTOUR',0);
set(gca,'Ydir','reverse')
title('Tex2 response (correct trials)')

ax3 = subplot(1,3,3);
plot_value_in_rois( cell_struct, 'photo_sta_amp',[256 256],ax3,'IF_NORM_PIX',0,'IF_CONTOUR',0);
set(gca,'Ydir','reverse')
title('Photo response')

% mark texture cells on FOV
mark_idx = find(extractfield(cell_struct,'pref_tex')==1);
mark_cells_on_fov(cell_struct,mark_idx,plot_color.stim1)
mark_idx = find(extractfield(cell_struct,'pref_tex')==2);
mark_cells_on_fov(cell_struct,mark_idx,plot_color.stim2)
mark_idx = find(extractfield(cell_struct,'is_photo')==1);
mark_cells_on_fov(cell_struct,mark_idx,plot_color.photo,'MarkerSize',300,'Linewidth',1)

%% get photoactivatable texture cells
tex_photo_idx.all = find(extractfield(cell_struct,'is_photo').*extractfield(cell_struct,'is_tuned')>0);
tex_photo_idx.targets1 = intersect(tex_photo_idx.all, find(extractfield(cell_struct,'pref_tex')==1));
tex_photo_idx.targets2 = intersect(tex_photo_idx.all, find(extractfield(cell_struct,'pref_tex')==2));
num_targets(1) = length(tex_photo_idx.targets1);
num_targets(2) = length(tex_photo_idx.targets2);

disp(['Num tex 1 photo cells: ' num2str(num_targets(1))])
disp(['Num tex 2 photo cells: ' num2str(num_targets(2))])

%% dummys for test - DELETE THIS
% tex_photo_idx.targets1 = [1,2,3,4,5];
% tex_photo_idx.targets2 = [6,7,9,10];

%% define number of cells to stimulate 
num_cells_per_stim = min([opt.exp_num_targets,numel(tex_photo_idx.targets1)-1,numel(tex_photo_idx.targets2)-1]);
disp(['Number of cells per photostim:' num2str(num_cells_per_stim)])
if num_cells_per_stim ==0
    warning('not enough targets!')
end
opt.num_cells_per_stim = num_cells_per_stim;
opt.shuff_order = shuff_trial_order;
%% =======================   MAKE OUTPUT FILES ============================
%% generate target order
% randomly select num_cells_per_stim targets in each trial
% while keeping random targets in different tex trials as same as possible

% generate two pools of target sets
target_cell_pool = {};
for i = 1:2
max_num_comb = max(arrayfun(@(x)numel(find(shuff_all_trial_types_idx == x)), find(trial_type_photo==i)));
target_cell_idx = nan(max_num_comb,opt.num_cells_per_stim);
for t = 1:max_num_comb
    this_rand_idx = randperm(num_targets(i));
    target_cell_idx(t,:) = sort(tex_photo_idx.(['targets' num2str(i)])(this_rand_idx(1:opt.num_cells_per_stim)));
end
target_cell_pool{i} = target_cell_idx;
end

% generate full array of target indices
all_target_cell_idx = zeros(opt.tot_num_trials,num_cells_per_stim);
for photo_type = 1:2
    for tex_type = 1:2
        this_trial_idx = find(shuff_photo_trial_types_idx == photo_type & shuff_tex_trial_types_idx == tex_type);
        all_target_cell_idx(this_trial_idx,:) = target_cell_pool{photo_type}(randperm(numel(this_trial_idx)),:);
    end
end

%% generate target order (for pyRTAOI)
pyrtaoi_stimOrder = struct();
pyrtaoi_stimOrder.target_idx_list = all_target_cell_idx;
target_centroid_x = zeros(size(all_target_cell_idx));
target_centroid_y = zeros(size(all_target_cell_idx));
for i = 1:opt.tot_num_trials
    if ~any(all_target_cell_idx(i,:) == 0)
    this_centroids = cell2mat({cell_struct(all_target_cell_idx(i,:)).centroid}');
    target_centroid_x(i,:) = this_centroids(:,2)';
    target_centroid_y(i,:) = this_centroids(:,1)';
    else
        continue
    end 
end

pyrtaoi_stimOrder.target_centroid_x = target_centroid_x;
pyrtaoi_stimOrder.target_centroid_y = target_centroid_y;

rtaoi_save_path = [save_path filesep 'pyrtaoi_stimOrder.mat'];
save(rtaoi_save_path,'pyrtaoi_stimOrder');
disp(['pyRTOAI target list saved to: ' rtaoi_save_path])

%% generate trial order (for pyBehavior)   
pyrtaoi_stimOrder.trialOrder = shuff_tex_trial_types_idx;
pyrtaoi_stimOrder.trialVariation = zeros(size(pyrtaoi_stimOrder.trialOrder));

% make catch trial idx to 3 for pybehav
pyrtaoi_stimOrder.trialOrder(pyrtaoi_stimOrder.trialOrder==0) = 3;
pybehav_save_path = [save_path filesep 'pybehav_stimOrder.txt'];
dlmwrite(pybehav_save_path, [pyrtaoi_stimOrder.trialOrder; pyrtaoi_stimOrder.trialVariation ] ,'delimiter',',') 
%% generate target tiff and holograms (for Blink if not using pyRTAOI)
% only save out unique tiffs and phase masks
[unique_targets, ~,unique_idx] = unique(all_target_cell_idx,'rows' );
all_target_set_idx = unique_idx;
dummy_img = zeros(512,512);
dummy_img(256,256)=1;
for i = 1:size(unique_targets,1)
    % make target tiff image and hologram
    this_target_idx = unique_targets(i,:);

    if(isequal(this_target_idx,zeros(size(this_target_idx))))
        % make a dummy target behind zero order blocker
        target_img = dummy_img;
    else
        target_centroids = cell2mat({cell_struct(this_target_idx).centroid}');
        target_img = make_target_image(target_centroids,opt.fov_size,opt.ds_factor);

    end
    % save target image
    imwrite(target_img,[target_tiff_save_path, filesep ['targets_' num2str(i)] '.tif']);
end
disp(['Unique target centroid images saved to: ' target_tiff_save_path])

target_files_info = dir(fullfile(target_tiff_save_path, '*.tif'));
target_file_full_names = fullfile(target_tiff_save_path,{target_files_info.name});
target_file_names = {target_files_info.name};
[phasemasks,~,phasemask_savepath] = SLMPhaseMaskMakerCUDA3D_v2_ZZ('FileName',target_file_full_names,'Do2DTransform',true,'Do3DTransform',false);
disp(['Unique phasemasks saved to: ' phasemask_savepath])

%% generate a folder of phase masks for blink to load
allphasemask_save_path = [target_tiff_save_path filesep 'AllPhaseMasks'];
if ~exist(allphasemask_save_path, 'dir')
    mkdir(allphasemask_save_path)
end
for i = 1:length(all_target_set_idx)
    this_target_set = all_target_set_idx(i);
    imwrite(phasemasks{this_target_set},[allphasemask_save_path, filesep ,'trial' num2str(i) 'phasemask_targets' num2str(this_target_set)  '.tif']);
end
disp(['Listed phasemasks (for blink) saved to: ' allphasemask_save_path])

%% generate triggers to spiral and blink (for packIO if not using pyRTAOI)
output_triggers = generate_tex_photo_triggers(pack_trigger_save_path,opt);
%% save to output




 

